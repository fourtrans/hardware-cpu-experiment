# 汇编级结构设计
## 设计原则
由于 x86 汇编程序只作为原型使用，之后需要转移到唐都试验箱上使用。考虑到向后迁移的需求，
在原型设计中我们有一些限制规则。
1. 由于存储器只有 256B，所以程序编写在满足可读性需求基础上尽可能精简。
2. 只使用JMP和JNZ跳转
3. 不允许使用乘除指令，使用子程序模拟实现


允许使用的指令一览表:  

> 硬件级指令
> |编号|指令|补充说明|
> |:-:|:-|:-|
> |1|MOV||
> |2|ADD||
> |3|AND||
> |4|JMP||
> |5|JNZ||
> |6|XCHG|只允许用于`ah<->al`这类，因为转移到唐都试验箱上是4个8位寄存器，本身就不是绑定的|

> 汇编级指令
> |编号|指令|
> |:-:|:-|
> |1|RET|
> |2|PUSH|
> |3|POP|
> |4|SHL|

另外关于程序量的限制：
> 所有汇编级指令均计算为3行，标签均算一行。预期所有代码行总和小于128行，最多不能超过180行。
> 每行代码计作 1 byte
> 数据段按照数据量计算
> 总计数据量应当小于 220 byte
## 算法
核心递推公式  
$$x_{n+1}=(a \cdot x_n + c)\ \%\ module$$
其中初始状态为：

> $x_0=97$
  
在 8bit 的运行环境下常数部分取值为：  

> $a=17$  
> $c=13$  
> $module=128$  

## 程序结构
|程序|功能|
|:-:|:-|
|main|程序入口，存在一个主循环，不断调用其他部分|
|MULTI|乘法指令汇编语言级模拟|
|LCG|算法迭代子程序|
|OUPUT|输出子程序|


## 接口设计

### MULTI 子程序
由于我们的CPU指令设计中没有乘法指令，故编写一段子程序进行乘法计算
|||
|:-|:-|
|**Input**|被乘数`AL`, 乘数`AH`|
|**Process**|`AL` <- `AL`*`AH`|
|**Output**|乘积`AL`|


### LCG 子程序
此子程序用于获取下一个随机数的值
|||
|:-|:-|
|**Input**|`AL`中是当前的值，即$x_{n}$|
|**Process**|`AL` <- (_A_ * `AL` + _C_) % MODULE|
|**Output**|`AL`更新为下一个值|


## OUPUT 子程序
用于输出AL中的内容
|||
|:-|:-|
|**Input**|`AL` 需要输出的值|
|**Process**|None|
|**Output**|None|
